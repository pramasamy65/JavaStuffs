
JUnit

	Open source framework to run test cases
	Run test cases - mvn clean test
	
Annotations
	
	@Test

	Per method - Suppose to be static or use class level @TestInstance(Lifecycle.PER_METHOD)
		@BeforeEach
		@AfterEach
	
	Per Class - Suppose to be static or use class level @TestInstance(Lifecycle.PER_CLASS)
		@BeforeAll
		@AfterAll
			
			@BeforeAll
			public static void beforeAll() {
				System.out.println("Before All...");
			}
			
@Nested class
  
		Testing hierarchy will be created
		Nested test classes work with non-static inner classes
		We can also access outer class variables inside inner class
		@Nested
		Class SmallOrder{
			List .....
			
			@BeforeEach()
			public static void BeforeEach() {
				System.out.println("BeforeEach ...");
			}
		}
		
	BDD - Behaviour Driven Development
		TDD + Behaviour (System Behaviour and end user experience)
	TDD - Test Driven Development 
		First will write Test cases and write code to pass to test cases
		Only developer know the code and flow. 
  
@DisplayName("Customer has enough points")

		Custom display names for test cases
		This will work class, method and nested class level
		
Assertions

		Single logic assertion is recommended
		
		assertEquals
		assertAll
		assertTimeout
		
@Disabled /  @Ignore

		- Ignore the test cases
		@Disabled("Implementation not completed Yet")
		
Assumptions

		Only execute if assumption is true or false
		If the assumption is true then only further assumptions are executed
		
API's
			assumeTrue(boolean assumption)
			assumeFalse(boolean assumption, String message)
		
	Test Interfaces and default methods
			
	@RepeatedTest - Repeating Tests
		Fixed number of repetitions
		
		@RepeatedTest(5)
		@RepeatedTest(value=5, name=" {displayName} -> {currentRepetition} / {totalRepetitions}")
		
		Repetition info also injected to methods
		
		@RepeatedTest(value=5, name=".........)
		void method1(RepetitionInfo repetitioninfo){
			repetitioninfo.getCurrentRepetition
			repetitioninfo.getTotalRepetitions
		}
		
	Dynamic Tests
		The standard tests annotated with @Test annotation are static tests which are fully specified at the compile time.
		A DynamicTest is a test generated during runtime. These tests are generated by a factory method annotated with the 
    
@TestFactory annotation
		
    @TestFactory method must return a Stream, Collection, Iterable, or Iterator of DynamicTest instances. 
    Returning anything else will result in a JUnitException
		
		The DynamicTests are executed differently than the standard @Tests and do not support lifecycle callbacks.
    Meaning, the @BeforeEach and the @AfterEach methods will not be called for the DynamicTests
		
    @TestFactory
			@TestFactory method cannot be static or private
		
		@TestFactory
		Collection<DynamicTest> dynamicTestsWithCollection() {
    		return Arrays.asList(
      			DynamicTest.dynamicTest("Add test",
        			() -> assertEquals(2, Math.addExact(1, 1))),
      			DynamicTest.dynamicTest("Multiply Test",
        			() -> assertEquals(4, Math.multiplyExact(2, 2))));
		}
		
@ParameterizedTest

		- Like Regular Test cycles
		
			@ParameterizedTest
			@valueSource(longs = {1,2,3,4})
			void method1(long productId){
			
			}
			
			valueSource will have primitive data types like String, int etc...
			 So this will run 4 times with 4 different injected values
			 
@EnumSource

		@EnumSource(value = ProductSizeEnum.class)
		void method1(ProductSizeEnum size){
		}
		- All Enum values are injected and executed based on enum count
		- We can also exclude few enums using configurations
		
@MethodSource
		
		
		
	
	
	
